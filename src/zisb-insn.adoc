=== Speculation Barrier Instructions

The Zisb extension provides three barrier instructions to control transient
execution:

* TEB (Transient Execution Barrier): due to control-flow prediction.
* MDB (Memory Disambiguation Barrier): due to data-dependency prediction.
* DPB (Data-Value Prediction Barrier): due to data-value prediction.

=== TEB - Transient Execution Barrier

The TEB instruction has the following barrier semantics:

* The TEB instruction cannot be speculatively executed due to control-flow
  speculation by instructions that appear in program order before TEB.
* Execution of instructions that follow TEB in program order cannot be observed
  through covert channels until TEB completes.

[NOTE]
====
These semantics allow execution of instructions that follow TEB, provided their
execution does not cause revelation of the data used by those instructions
through a covert channel.

Processors may speculate the control flow of a program by predicting the
outcome of a branch using data structures such as a pattern history table
(PHT) before the branch is executed. Eventually, the prediction is verified.
If a misprediction is detected, the speculatively executed instructions are
discarded, the architectural state is recovered, and control flow continues
along the correct path. Speculative execution that occurs before the branch
outcome is verified may be used to leak data through side channels. The TEB
may be used to control such control-flow speculation, as illustrated by the
following code snippet.

[listing]
 1. void bounds_check_bypass_example(uint32_t x, 
 2.  uint8_t *array1, uint32_t len1, 
 3.  uint8_t *array2, uint32_t len2) {
 4. if (x < len1)) { 
 5.     bgeu    a0, a2, L3
 6. // If the branch at line 5 mispredicts then the load at line 14
 7. // may use an out-of-bound index into array1 and disclose its
 8. // contents using a side channel caused by the load at line 18
 9. // The TEB at line 11 prevents execution of the loads at line 14
10. // and 18 until the branch resolves.
11.     teb
12.     y = array2[array1[x] * 4096];
13.       add    a5, a0, a1
14.       lbu    a5, 0(a1)
15.       sext.w a5, a5
16.       sllw   a5, a5,0xc
17.       add    a5, a5, a3
18.       lbu    a5,0(a5)
19. }
20. L3:

====

=== MDB - Memory Disambiguation Barrier

The MDB instruction has the following barrier semantics:

* An instruction that loads from memory and appears in program order after MDB
  must obtain its data from an instruction that stores to the same physical
  memory location and appears in program order before MDB. These semantics shall
  be enforced regardless of whether the load and/or the store are speculative
  and regardless of whether the load and/or store eventually complete.

[NOTE]
====
This semantic prevents loads that appear in program order after MDB from
bypassing a store that appears in program order before MDB unless the physical
address to which that store will write has been determined. A load that appears
in program order after MDB must obtain its data either from a preceding store
that has been determined to write to the same physical memory location (e.g.,
through store-to-load forwarding) or from the memory that the store writes to.
Such a load may execute even if it is speculative.
====

* Instructions that load from memory and precede MDB in program order must not
  speculatively obtain their data from instructions that store to memory and
  appear in program order after MDB.

[NOTE]
====
A load instruction may depend on a preceding store. If the address of the
preceding store is not yet known, an implementation may either block loads
until all preceding store addresses are known or may employ a memory
disambiguation predictor to predict whether a load is dependent on a previous
store. When the disambiguator predicts that a load does not have such a
dependency, the load obtains its data from the data cache or memory.
Eventually, the prediction is verified. If an actual conflict is detected,
the load and all succeeding instructions are re-executed. The speculative
store bypass that occurs when the prediction is wrong may be exploited to
leak data using side channels. The MDB may be used to control such
data-dependency speculation, as illustrated by the following code snippet.

[listing]
 1. typedef void (*msg_handler)(uint8_t *data, uint32_t size);
 2. extern void proc1(uint8_t *data, uint32_t size);
 3. extern void proc2(uint8_t *data, uint32_t size);
 4. extern uint32_t mode;
 5. msg_handler get_handler(uint32_t mode) {
 6.   return (mode == 0) ? proc1 : proc2;
 7. }
 8. void memory_disambiguation_example(uint8_t *data, uint32_t len) {
 9.       add  sp, sp, -32
10.       sd   ra, 24(sp)
11.       sd   a0, 16(sp)
12.       sd   a1,  8(sp)     
13.   msg_handler mh = get_handler(mode);
14.       la   a0, mode
15.       la   ra, get_handler
16.       jalr ra
17. // The address of the handler provided by get_handler is stored
18. // in the variable `mh` by the store at line 19. 
19.       sd   a0, 0(sp)
20.   mh(data, len);
21. // If the load at line 32 bypasses the store at line 19, then it
22. // may read the old contents of the stack and provide that as
23. // the jump target to JALR at line 33. The old contents may be
24. // controlled by untrusted entities and allow speculative
25. // execution of a disclosure gadget that could leak information
26. // through a side channel. The MDB at line 29 ensures that the
27. // LD at line 32 cannot bypass SD at line 19 thereby ensuring
28. // that it gets the data stored by that SD.
29.       mdb
30.       ld   a0, 16(sp)
31.       ld   a1,  8(sp)
32.       ld   ra,  0(sp)
33.       jalr ra
34.       ld   ra, 24(sp)
35.       add  sp, sp, 32
36.       ret
37. }

====

==== DPB - Data-value Prediction Barrier

The DPB instruction has the following barrier semantics:

* Instructions that appear in program order after a DPB must not execute with
  operand values that are the result of data-value speculation by instructions
  in program order before the DPB, until the DPB completes, if such execution
  could be observed through covert channels.

[NOTE]
====
Modern processors may predict the result of computations or load operations
based on previously observed data values. These predictions, when used
speculatively, can be influenced by attackers to access out-of-bounds or
unauthorized memory. Eventually, the prediction is verified. If a
misprediction is detected, all succeeding instructions are re-executed. When
the prediction is wrong, the transient execution may be exploited to leak
data using covert channels. The DPB may be used to control such data-value
speculation, as illustrated by the following code snippet.

[listing]
 1. uint32_t cur_priv;
 2. uint8_t data_value_prediction_example(uint32_t index, 
 3.                   uint8_t *priv_array, uint8_t *unpriv_array) {
 4.   uint8_t *array;
 5.   array = (cur_priv == 0) ? priv_array : unpriv_array;
 6.       la         t0, cur_priv
 7.       lw         t0, 0(t0)
 8.       la         a1, priv_array
 9.       la         a2, unpriv_array
10.   // If the data value of cur_priv was predicted by the load at line 7
11.   // and the prediction was incorrect, then data may be loaded from the
12.   // wrong array speculatively by the load at line 21. The DPB at line
13.   // 15 ensures that the load at line 21 will not execute speculatively
14.   // using a predicted data value.
15.       dpb
16.       czero.eqz  a2, a2, t0
17.       czero.nez  a1, a1, t0
18.       or         t0, a1, a2
19.   return array[index];         
20.       add        t0, t0, a0
21.       lbu        a0, 0(t0)
22. }

====
